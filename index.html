<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DES Encryption/Decryption Visualizer</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    
    .container {
      max-width: 1000px;
      margin: 0 auto;
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 30px;
    }
    
    .input-section {
      margin-bottom: 20px;
    }
    
    .input-row {
      display: flex;
      margin-bottom: 15px;
      align-items: center;
    }
    
    label {
      width: 120px;
      font-weight: bold;
    }
    
    input, textarea {
      flex: 1;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }
    
    .button-group {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    button {
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #2980b9;
    }
    
    #reset {
      background-color: #e74c3c;
    }
    
    #reset:hover {
      background-color: #c0392b;
    }
    
    .result-section {
      margin-top: 20px;
    }
    
    .result {
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-all;
    }
    
    .steps-container {
      margin-top: 30px;
    }
    
    .step {
      margin-bottom: 15px;
      border-left: 3px solid #3498db;
      padding-left: 15px;
    }
    
    .step-title {
      font-weight: bold;
      margin-bottom: 5px;
      color: #2c3e50;
    }
    
    .step-content {
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-all;
      background-color: #f9f9f9;
      padding: 10px;
      border-radius: 4px;
    }
    
    .step-diagram {
      display: flex;
      justify-content: center;
      margin: 15px 0;
    }
    
    .des-round {
      border: 1px solid #ddd;
      padding: 15px;
      margin: 10px 0;
      border-radius: 4px;
      background-color: #f9f9f9;
    }
    
    .des-round-title {
      font-weight: bold;
      margin-bottom: 10px;
      color: #2c3e50;
    }
    
    .des-blocks {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 20px;
      margin: 20px 0;
    }
    
    .block {
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      width: 45%;
      min-width: 300px;
    }
    
    .block-title {
      font-weight: bold;
      margin-bottom: 10px;
      color: #2c3e50;
    }
    
    .bit-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 5px;
      margin-top: 10px;
    }
    
    .bit-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 30px;
      background-color: #f1f1f1;
      border-radius: 4px;
      font-family: monospace;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    .bit-cell.highlighted {
      background-color: #f39c12;
      color: white;
    }
    
    .operation {
      text-align: center;
      font-size: 1.5rem;
      margin: 10px 0;
      color: #3498db;
    }
    
    .arrow {
      text-align: center;
      font-size: 1.5rem;
      margin: 10px 0;
      color: #7f8c8d;
    }

    .tabs {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #ddd;
    }
    
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      margin-right: 5px;
    }
    
    .tab.active {
      background-color: #fff;
      border-color: #ddd;
      border-bottom: 1px solid #fff;
      margin-bottom: -1px;
      font-weight: bold;
      color: #3498db;
    }
    
    .tab:hover:not(.active) {
      background-color: #f1f1f1;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }

    .key-schedule {
      margin-top: 20px;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      background-color: #f9f9f9;
    }

    .key-schedule-title {
      font-weight: bold;
      margin-bottom: 10px;
      color: #2c3e50;
    }

    .subkey {
      margin-bottom: 8px;
      font-family: monospace;
    }

    .subkey-label {
      font-weight: bold;
      display: inline-block;
      width: 80px;
    }

    /* Animation effects */
    @keyframes highlight {
      0% { background-color: #f1f1f1; }
      50% { background-color: #f39c12; }
      100% { background-color: #f1f1f1; }
    }

    .animate {
      animation: highlight 1.5s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>DES Encryption/Decryption Visualizer</h1>

    <div class="tabs">
      <div id="tab-encrypt" class="tab active">Encrypt</div>
      <div id="tab-decrypt" class="tab">Decrypt</div>
      <div id="tab-about" class="tab">About DES</div>
    </div>

    <div id="content-encrypt" class="tab-content active">
      <div class="input-section">
        <div class="input-row">
          <label for="plaintext">Plaintext:</label>
          <input type="text" id="plaintext" placeholder="Enter plaintext (ASCII text)">
        </div>
        <div class="input-row">
          <label for="key">Key (64-bit):</label>
          <input type="text" id="key" placeholder="Enter key (8 ASCII chars or 16 hex digits)">
        </div>
        <div class="button-group">
          <button id="encrypt">Encrypt</button>
          <button id="reset">Reset</button>
        </div>
      </div>

      <div class="result-section">
        <h3>Result:</h3>
        <div id="encryption-result" class="result">Encrypted output will appear here</div>
      </div>

      <div class="steps-container" id="encryption-steps">
        <!-- Encryption steps will be dynamically added here -->
      </div>
    </div>

    <div id="content-decrypt" class="tab-content">
      <div class="input-section">
        <div class="input-row">
          <label for="ciphertext">Ciphertext:</label>
          <input type="text" id="ciphertext" placeholder="Enter ciphertext (hex format)">
        </div>
        <div class="input-row">
          <label for="decrypt-key">Key (64-bit):</label>
          <input type="text" id="decrypt-key" placeholder="Enter key (8 ASCII chars or 16 hex digits)">
        </div>
        <div class="button-group">
          <button id="decrypt">Decrypt</button>
          <button id="reset-decrypt">Reset</button>
        </div>
      </div>

      <div class="result-section">
        <h3>Result:</h3>
        <div id="decryption-result" class="result">Decrypted output will appear here</div>
      </div>

      <div class="steps-container" id="decryption-steps">
        <!-- Decryption steps will be dynamically added here -->
      </div>
    </div>

    <div id="content-about" class="tab-content">
      <h2>About the DES Algorithm</h2>
      <p>The Data Encryption Standard (DES) is a symmetric-key block cipher published by the National Institute of Standards and Technology (NIST) in 1977.</p>
      
      <h3>Key Characteristics:</h3>
      <ul>
        <li><strong>Block Size:</strong> 64 bits</li>
        <li><strong>Key Size:</strong> 64 bits (56 bits effective + 8 parity bits)</li>
        <li><strong>Number of Rounds:</strong> 16</li>
      </ul>

      <h3>Algorithm Overview:</h3>
      <ol>
        <li><strong>Initial Permutation (IP):</strong> Rearranges the bits of the plaintext block</li>
        <li><strong>16 Rounds of Processing:</strong> Each round consists of:
          <ul>
            <li>Splitting the block into left and right halves</li>
            <li>Expanding the right half to 48 bits</li>
            <li>XORing with a round key</li>
            <li>Passing through S-boxes to convert 48 bits to 32 bits</li>
            <li>Permutation of the result</li>
            <li>XORing with the left half to create the new right half</li>
            <li>Using the old right half as the new left half</li>
          </ul>
        </li>
        <li><strong>Final Permutation (IP<sup>-1</sup>):</strong> The inverse of the initial permutation</li>
      </ol>

      <h3>Key Schedule:</h3>
      <p>The 16 round keys are derived from the main key through a series of permutations and shifts.</p>

      <h3>Security:</h3>
      <p>DES is now considered insecure due to its small key size (effectively 56 bits). It was officially withdrawn as a standard in 2005 and replaced by more secure algorithms like AES.</p>
      
      <h3>Visualization:</h3>
      <p>This tool demonstrates the complete DES encryption and decryption process, showing the transformation of data through each round.</p>
    </div>
    <footer>
        All copyrights © of this product are reserved by <a href="https://www.linkedin.com/in/muhammad-usman-34bba325b/" target="_blank">Muhammad Usman </a>
    </footer>
  </div>

  <script>
    // Tab functionality
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        
        tab.classList.add('active');
        document.getElementById('content-' + tab.id.split('-')[1]).classList.add('active');
      });
    });

    // DES Implementation
    class DES {
      constructor() {
        // Initial Permutation table
        this.IP = [
          58, 50, 42, 34, 26, 18, 10, 2,
          60, 52, 44, 36, 28, 20, 12, 4,
          62, 54, 46, 38, 30, 22, 14, 6,
          64, 56, 48, 40, 32, 24, 16, 8,
          57, 49, 41, 33, 25, 17, 9, 1,
          59, 51, 43, 35, 27, 19, 11, 3,
          61, 53, 45, 37, 29, 21, 13, 5,
          63, 55, 47, 39, 31, 23, 15, 7
        ];

        // Final Permutation table
        this.FP = [
          40, 8, 48, 16, 56, 24, 64, 32,
          39, 7, 47, 15, 55, 23, 63, 31,
          38, 6, 46, 14, 54, 22, 62, 30,
          37, 5, 45, 13, 53, 21, 61, 29,
          36, 4, 44, 12, 52, 20, 60, 28,
          35, 3, 43, 11, 51, 19, 59, 27,
          34, 2, 42, 10, 50, 18, 58, 26,
          33, 1, 41, 9, 49, 17, 57, 25
        ];

        // PC-1 table (Permuted Choice 1 - for key)
        this.PC1 = [
          57, 49, 41, 33, 25, 17, 9,
          1, 58, 50, 42, 34, 26, 18,
          10, 2, 59, 51, 43, 35, 27,
          19, 11, 3, 60, 52, 44, 36,
          63, 55, 47, 39, 31, 23, 15,
          7, 62, 54, 46, 38, 30, 22,
          14, 6, 61, 53, 45, 37, 29,
          21, 13, 5, 28, 20, 12, 4
        ];

        // PC-2 table (Permuted Choice 2 - for subkey generation)
        this.PC2 = [
          14, 17, 11, 24, 1, 5,
          3, 28, 15, 6, 21, 10,
          23, 19, 12, 4, 26, 8,
          16, 7, 27, 20, 13, 2,
          41, 52, 31, 37, 47, 55,
          30, 40, 51, 45, 33, 48,
          44, 49, 39, 56, 34, 53,
          46, 42, 50, 36, 29, 32
        ];

        // Expansion table - expands 32-bit to 48-bit
        this.E = [
          32, 1, 2, 3, 4, 5,
          4, 5, 6, 7, 8, 9,
          8, 9, 10, 11, 12, 13,
          12, 13, 14, 15, 16, 17,
          16, 17, 18, 19, 20, 21,
          20, 21, 22, 23, 24, 25,
          24, 25, 26, 27, 28, 29,
          28, 29, 30, 31, 32, 1
        ];

        // Substitution boxes (S-boxes)
        this.S = [
          // S1
          [
            [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
            [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
            [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
            [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
          ],
          // S2
          [
            [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
            [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
            [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
            [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]
          ],
          // S3
          [
            [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
            [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
            [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
            [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]
          ],
          // S4
          [
            [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
            [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
            [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
            [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]
          ],
          // S5
          [
            [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
            [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
            [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
            [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]
          ],
          // S6
          [
            [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
            [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
            [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
            [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]
          ],
          // S7
          [
            [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
            [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
            [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
            [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]
          ],
          // S8
          [
            [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
            [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
            [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
            [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]
          ]
        ];

        // Permutation table for the f function
        this.P = [
          16, 7, 20, 21, 29, 12, 28, 17,
          1, 15, 23, 26, 5, 18, 31, 10,
          2, 8, 24, 14, 32, 27, 3, 9,
          19, 13, 30, 6, 22, 11, 4, 25
        ];

        // Number of left shifts for each round in key schedule
        this.shifts = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
      }

      // Convert a string to a binary array of bits
      stringToBinary(str) {
        const result = [];
        for (let i = 0; i < str.length; i++) {
          const charCode = str.charCodeAt(i);
          for (let j = 7; j >= 0; j--) {
            result.push((charCode >> j) & 1);
          }
        }
        return result;
      }

      // Convert a hex string to a binary array of bits
      hexToBinary(hex) {
        const result = [];
        for (let i = 0; i < hex.length; i++) {
          const decimal = parseInt(hex[i], 16);
          for (let j = 3; j >= 0; j--) {
            result.push((decimal >> j) & 1);
          }
        }
        return result;
      }

      // Convert a binary array to a hex string
      binaryToHex(binary) {
        let hex = '';
        for (let i = 0; i < binary.length; i += 4) {
          let value = 0;
          for (let j = 0; j < 4; j++) {
            value = (value << 1) | binary[i + j];
          }
          hex += value.toString(16);
        }
        return hex;
      }

      // Convert a binary array to a string
      binaryToString(binary) {
        let result = '';
        for (let i = 0; i < binary.length; i += 8) {
          let charCode = 0;
          for (let j = 0; j < 8; j++) {
            charCode = (charCode << 1) | binary[i + j];
          }
          result += String.fromCharCode(charCode);
        }
        return result;
      }

      // Apply a permutation to a binary array
      permute(input, table) {
        const output = [];
        for (let i = 0; i < table.length; i++) {
          output.push(input[table[i] - 1]);
        }
        return output;
      }

      // Left circular shift (rotation)
      leftShift(bits, count) {
        const result = [...bits];
        for (let i = 0; i < count; i++) {
          const temp = result.shift();
          result.push(temp);
        }
        return result;
      }

      // XOR two binary arrays
      xor(a, b) {
        return a.map((bit, index) => bit ^ b[index]);
      }

      // S-box substitution
      sBox(input) {
        const output = [];
        for (let i = 0; i < 8; i++) {
          const block = input.slice(i * 6, (i + 1) * 6);
          // First and last bits determine row
          const row = (block[0] << 1) | block[5];
          // Middle 4 bits determine column
          const col = (block[1] << 3) | (block[2] << 2) | (block[3] << 1) | block[4];
          
          // Get 4-bit value from S-box
          const value = this.S[i][row][col];
          
          // Convert to binary and add to output
          for (let j = 3; j >= 0; j--) {
            output.push((value >> j) & 1);
          }
        }
        return output;
      }

      // The f function used in each round
      f(R, roundKey) {
        // Expand R from 32 to 48 bits
        const expandedR = this.permute(R, this.E);
        
        // XOR with round key
        const xored = this.xor(expandedR, roundKey);
        
        // S-box substitution
        const sBoxOutput = this.sBox(xored);
        
        // Permutation
        return this.permute(sBoxOutput, this.P);
      }

      // Generate 16 subkeys from the main key
      generateSubkeys(key) {
        const subkeys = [];
        
        // Apply PC-1 permutation to the key
        const permutedKey = this.permute(key, this.PC1);
        
        // Split into left and right halves
        let C = permutedKey.slice(0, 28);
        let D = permutedKey.slice(28, 56);
        
        // Generate 16 pairs of subkeys
        for (let i = 0; i < 16; i++) {
          // Apply shifts
          C = this.leftShift(C, this.shifts[i]);
          D = this.leftShift(D, this.shifts[i]);
          
          // Combine C and D
          const combined = [...C, ...D];
          
          // Apply PC-2 permutation
          const subkey = this.permute(combined, this.PC2);
          subkeys.push(subkey);
        }
        
        return subkeys;
      }

      // Encrypt a 64-bit block
      encryptBlock(block, key, stepsCallback = null) {
        const steps = [];
        
        // Generate subkeys
        const subkeys = this.generateSubkeys(key);
        
        if (stepsCallback) {
          steps.push({
            title: "Key Schedule",
            content: "Generating 16 subkeys from the main key",
            subkeys: subkeys.map((key, i) => ({ 
              index: i + 1, 
              key: this.binaryToHex(key) 
            }))
          });
        }
        
        // Apply initial permutation
        const ip = this.permute(block, this.IP);
        
        if (stepsCallback) {
          steps.push({
            title: "Initial Permutation (IP)",
            content: "Rearranging the bits of the plaintext block",
            before: this.binaryToHex(block),
            after: this.binaryToHex(ip)
          });
        }
        
        // Split into left and right halves
        let L = ip.slice(0, 32);
        let R = ip.slice(32, 64);
        
        // 16 rounds of encryption
        for (let i = 0; i < 16; i++) {
          const oldL = [...L];
          const oldR = [...R];
          
          // L_i = R_{i-1}
          L = oldR;
          
          // R_i = L_{i-1} XOR f(R_{i-1}, K_i)
          const fOutput = this.f(oldR, subkeys[i]);
          R = this.xor(oldL, fOutput);
          
          if (stepsCallback) {
            steps.push({
              title: `Round ${i + 1}`,
              content: `Processing round ${i + 1} with subkey ${i + 1}`,
              leftBefore: this.binaryToHex(oldL),
              rightBefore: this.binaryToHex(oldR),
              leftAfter: this.binaryToHex(L),
              rightAfter: this.binaryToHex(R),
              subkey: this.binaryToHex(subkeys[i]),
              fOutput: this.binaryToHex(fOutput)
            });
          }
        }
        
        // Swap L and R for the final permutation
        const combined = [...R, ...L];
        
        // Apply final permutation
        const result = this.permute(combined, this.FP);
        
        if (stepsCallback) {
          steps.push({
            title: "Final Permutation (FP)",
            content: "Applying the inverse of the initial permutation",
            before: this.binaryToHex([...R, ...L]),
            after: this.binaryToHex(result)
          });
          
          stepsCallback(steps);
        }
        
        return result;
      }

      // Decrypt a 64-bit block
      decryptBlock(block, key, stepsCallback = null) {
        const steps = [];
        
        // Generate subkeys (same as encryption)
        const subkeys = this.generateSubkeys(key);
        
        if (stepsCallback) {
          steps.push({
            title: "Key Schedule",
            content: "Generating 16 subkeys from the main key",
            subkeys: subkeys.map((key, i) => ({ 
              index: i + 1, 
              key: this.binaryToHex(key) 
            }))
          });
        }
        
        // Apply initial permutation
        const ip = this.permute(block, this.IP);
        
        if (stepsCallback) {
          steps.push({
            title: "Initial Permutation (IP)",
            content: "Rearranging the bits of the ciphertext block",
            before: this.binaryToHex(block),
            after: this.binaryToHex(ip)
          });
        }
        
        // Split into left and right halves
        let L = ip.slice(0, 32);
        let R = ip.slice(32, 64);
        
        // 16 rounds of decryption (using keys in reverse order)
        for (let i = 15; i >= 0; i--) {
          const oldL = [...L];
          const oldR = [...R];
          
          // L_i = R_{i-1}
          L = oldR;
          
          // R_i = L_{i-1} XOR f(R_{i-1}, K_{16-i})
          const fOutput = this.f(oldR, subkeys[i]);
          R = this.xor(oldL, fOutput);
          
          if (stepsCallback) {
            steps.push({
              title: `Round ${16 - i}`,
              content: `Processing round ${16 - i} with subkey ${i + 1} (in reverse order)`,
              leftBefore: this.binaryToHex(oldL),
              rightBefore: this.binaryToHex(oldR),
              leftAfter: this.binaryToHex(L),
              rightAfter: this.binaryToHex(R),
              subkey: this.binaryToHex(subkeys[i]),
              fOutput: this.binaryToHex(fOutput)
            });
          }
        }
        
        // Swap L and R for the final permutation
        const combined = [...R, ...L];
        
        // Apply final permutation
        const result = this.permute(combined, this.FP);
        
        if (stepsCallback) {
          steps.push({
            title: "Final Permutation (FP)",
            content: "Applying the inverse of the initial permutation",
            before: this.binaryToHex([...R, ...L]),
            after: this.binaryToHex(result)
          });
          
          stepsCallback(steps);
        }
        
        return result;
      }

      // Encrypt a message
      encrypt(message, keyStr, stepsCallback = null) {
        // Convert message and key to binary
        let messageBinary;
        if (message.length === 16 && /^[0-9A-Fa-f]+$/.test(message)) {
          messageBinary = this.hexToBinary(message);
        } else {
          messageBinary = this.stringToBinary(message);
        }
        
        let keyBinary;
        if (keyStr.length === 16 && /^[0-9A-Fa-f]+$/.test(keyStr)) {
          keyBinary = this.hexToBinary(keyStr);
        } else {
          keyBinary = this.stringToBinary(keyStr.padEnd(8, ' ').substring(0, 8));
        }
        
        // Pad message to multiple of 64 bits if needed
        while (messageBinary.length % 64 !== 0) {
          messageBinary.push(0);
        }
        
        // Process each 64-bit block
        let result = [];
        for (let i = 0; i < messageBinary.length; i += 64) {
          const block = messageBinary.slice(i, i + 64);
          const blockStepsCallback = stepsCallback && i === 0 ? stepsCallback : null;
          const encryptedBlock = this.encryptBlock(block, keyBinary, blockStepsCallback);
          result = [...result, ...encryptedBlock];
        }
        
        return this.binaryToHex(result);
      }

      // Decrypt a message
      decrypt(ciphertext, keyStr, stepsCallback = null) {
        // Convert ciphertext (hex) and key to binary
        const ciphertextBinary = this.hexToBinary(ciphertext);
        
        let keyBinary;
        if (keyStr.length === 16 && /^[0-9A-Fa-f]+$/.test(keyStr)) {
          keyBinary = this.hexToBinary(keyStr);
        } else {
          keyBinary = this.stringToBinary(keyStr.padEnd(8, ' ').substring(0, 8));
        }
        
        // Process each 64-bit block
        let result = [];
        for (let i = 0; i < ciphertextBinary.length; i += 64) {
          const block = ciphertextBinary.slice(i, i + 64);
          const blockStepsCallback = stepsCallback && i === 0 ? stepsCallback : null;
          const decryptedBlock = this.decryptBlock(block, keyBinary, blockStepsCallback);
          result = [...result, ...decryptedBlock];
        }
        
        return this.binaryToString(result);
      }
    }

    // UI interaction
    const des = new DES();
    
    // Encrypt function
    document.getElementById('encrypt').addEventListener('click', () => {
      const plaintext = document.getElementById('plaintext').value;
      const key = document.getElementById('key').value;
      
      if (!plaintext || !key) {
        alert('Please enter both plaintext and key');
        return;
      }
      
      if (key.length !== 8 && !(key.length === 16 && /^[0-9A-Fa-f]+$/.test(key))) {
        alert('Key must be 8 ASCII characters or 16 hex digits');
        return;
      }
      
      document.getElementById('encryption-steps').innerHTML = '';
      
      const ciphertext = des.encrypt(plaintext, key, steps => {
        displayEncryptionSteps(steps);
      });
      
      document.getElementById('encryption-result').textContent = ciphertext;
    });
    
    // Decrypt function
    document.getElementById('decrypt').addEventListener('click', () => {
      const ciphertext = document.getElementById('ciphertext').value;
      const key = document.getElementById('decrypt-key').value;
      
      if (!ciphertext || !key) {
        alert('Please enter both ciphertext and key');
        return;
      }
      
      if (!/^[0-9A-Fa-f]+$/.test(ciphertext)) {
        alert('Ciphertext must be in hexadecimal format');
        return;
      }
      
      if (key.length !== 8 && !(key.length === 16 && /^[0-9A-Fa-f]+$/.test(key))) {
        alert('Key must be 8 ASCII characters or 16 hex digits');
        return;
      }
      
      document.getElementById('decryption-steps').innerHTML = '';
      
      const plaintext = des.decrypt(ciphertext, key, steps => {
        displayDecryptionSteps(steps);
      });
      
      document.getElementById('decryption-result').textContent = plaintext;
    });
    
    // Reset functions
    document.getElementById('reset').addEventListener('click', () => {
      document.getElementById('plaintext').value = '';
      document.getElementById('key').value = '';
      document.getElementById('encryption-result').textContent = 'Encrypted output will appear here';
      document.getElementById('encryption-steps').innerHTML = '';
    });
    
    document.getElementById('reset-decrypt').addEventListener('click', () => {
      document.getElementById('ciphertext').value = '';
      document.getElementById('decrypt-key').value = '';
      document.getElementById('decryption-result').textContent = 'Decrypted output will appear here';
      document.getElementById('decryption-steps').innerHTML = '';
    });
    
    // Display encryption steps visually
    function displayEncryptionSteps(steps) {
      const stepsContainer = document.getElementById('encryption-steps');
      stepsContainer.innerHTML = '<h2>DES Encryption Steps</h2>';
      
      // Process each step
      steps.forEach(step => {
        const stepElement = document.createElement('div');
        stepElement.className = 'step';
        
        const titleElement = document.createElement('div');
        titleElement.className = 'step-title';
        titleElement.textContent = step.title;
        stepElement.appendChild(titleElement);
        
        const contentElement = document.createElement('div');
        contentElement.className = 'step-content';
        contentElement.textContent = step.content;
        stepElement.appendChild(contentElement);
        
        // Key Schedule visualization
        if (step.title === "Key Schedule") {
          const keySchedule = document.createElement('div');
          keySchedule.className = 'key-schedule';
          
          const keyScheduleTitle = document.createElement('div');
          keyScheduleTitle.className = 'key-schedule-title';
          keyScheduleTitle.textContent = 'Generated Subkeys:';
          keySchedule.appendChild(keyScheduleTitle);
          
          step.subkeys.forEach(subkey => {
            const subkeyElement = document.createElement('div');
            subkeyElement.className = 'subkey';
            
            const subkeyLabel = document.createElement('span');
            subkeyLabel.className = 'subkey-label';
            subkeyLabel.textContent = `Subkey ${subkey.index}:`;
            subkeyElement.appendChild(subkeyLabel);
            
            const subkeyValue = document.createElement('span');
            subkeyValue.textContent = subkey.key;
            subkeyElement.appendChild(subkeyValue);
            
            keySchedule.appendChild(subkeyElement);
          });
          
          stepElement.appendChild(keySchedule);
        }
        
        // Initial or Final Permutation visualization
        if (step.title === "Initial Permutation (IP)" || step.title === "Final Permutation (FP)") {
          const beforeAfter = document.createElement('div');
          beforeAfter.className = 'des-blocks';
          
          // Before block
          const beforeBlock = document.createElement('div');
          beforeBlock.className = 'block';
          
          const beforeTitle = document.createElement('div');
          beforeTitle.className = 'block-title';
          beforeTitle.textContent = 'Before:';
          beforeBlock.appendChild(beforeTitle);
          
          const beforeValue = document.createElement('div');
          beforeValue.textContent = step.before;
          beforeBlock.appendChild(beforeValue);
          
          beforeAfter.appendChild(beforeBlock);
          
          // Arrow
          const arrow = document.createElement('div');
          arrow.className = 'arrow';
          arrow.textContent = '→';
          beforeAfter.appendChild(arrow);
          
          // After block
          const afterBlock = document.createElement('div');
          afterBlock.className = 'block';
          
          const afterTitle = document.createElement('div');
          afterTitle.className = 'block-title';
          afterTitle.textContent = 'After:';
          afterBlock.appendChild(afterTitle);
          
          const afterValue = document.createElement('div');
          afterValue.textContent = step.after;
          afterBlock.appendChild(afterValue);
          
          beforeAfter.appendChild(afterBlock);
          
          stepElement.appendChild(beforeAfter);
        }
        
        // Round visualization
        if (step.title.startsWith("Round")) {
          const roundElement = document.createElement('div');
          roundElement.className = 'des-round';
          
          const roundTitle = document.createElement('div');
          roundTitle.className = 'des-round-title';
          roundTitle.textContent = `Round ${step.title.split(' ')[1]} Details:`;
          roundElement.appendChild(roundTitle);
          
          // Before state
          const beforeState = document.createElement('div');
          beforeState.className = 'des-blocks';
          
          const leftBeforeBlock = document.createElement('div');
          leftBeforeBlock.className = 'block';
          
          const leftBeforeTitle = document.createElement('div');
          leftBeforeTitle.className = 'block-title';
          leftBeforeTitle.textContent = 'Left Half (Before):';
          leftBeforeBlock.appendChild(leftBeforeTitle);
          
          const leftBeforeValue = document.createElement('div');
          leftBeforeValue.textContent = step.leftBefore;
          leftBeforeBlock.appendChild(leftBeforeValue);
          
          beforeState.appendChild(leftBeforeBlock);
          
          const rightBeforeBlock = document.createElement('div');
          rightBeforeBlock.className = 'block';
          
          const rightBeforeTitle = document.createElement('div');
          rightBeforeTitle.className = 'block-title';
          rightBeforeTitle.textContent = 'Right Half (Before):';
          rightBeforeBlock.appendChild(rightBeforeTitle);
          
          const rightBeforeValue = document.createElement('div');
          rightBeforeValue.textContent = step.rightBefore;
          rightBeforeBlock.appendChild(rightBeforeValue);
          
          beforeState.appendChild(rightBeforeBlock);
          
          roundElement.appendChild(beforeState);
          
          // Operation details
          const operationDetails = document.createElement('div');
          operationDetails.className = 'operation';
          operationDetails.textContent = 'Applying F function with Subkey: ' + step.subkey;
          roundElement.appendChild(operationDetails);
          
          // After state
          const afterState = document.createElement('div');
          afterState.className = 'des-blocks';
          
          const leftAfterBlock = document.createElement('div');
          leftAfterBlock.className = 'block';
          
          const leftAfterTitle = document.createElement('div');
          leftAfterTitle.className = 'block-title';
          leftAfterTitle.textContent = 'Left Half (After):';
          leftAfterBlock.appendChild(leftAfterTitle);
          
          const leftAfterValue = document.createElement('div');
          leftAfterValue.textContent = step.leftAfter;
          leftAfterBlock.appendChild(leftAfterValue);
          
          afterState.appendChild(leftAfterBlock);
          
          const rightAfterBlock = document.createElement('div');
          rightAfterBlock.className = 'block';
          
          const rightAfterTitle = document.createElement('div');
          rightAfterTitle.className = 'block-title';
          rightAfterTitle.textContent = 'Right Half (After):';
          rightAfterBlock.appendChild(rightAfterTitle);
          
          const rightAfterValue = document.createElement('div');
          rightAfterValue.textContent = step.rightAfter;
          rightAfterBlock.appendChild(rightAfterValue);
          
          afterState.appendChild(rightAfterBlock);
          
          roundElement.appendChild(afterState);
          
          stepElement.appendChild(roundElement);
        }
        
        stepsContainer.appendChild(stepElement);
      });
    }
    
    // Display decryption steps visually (similar to encryption)
    function displayDecryptionSteps(steps) {
      const stepsContainer = document.getElementById('decryption-steps');
      stepsContainer.innerHTML = '<h2>DES Decryption Steps</h2>';
      
      // Process each step (same logic as displayEncryptionSteps)
      steps.forEach(step => {
        const stepElement = document.createElement('div');
        stepElement.className = 'step';
        
        const titleElement = document.createElement('div');
        titleElement.className = 'step-title';
        titleElement.textContent = step.title;
        stepElement.appendChild(titleElement);
        
        const contentElement = document.createElement('div');
        contentElement.className = 'step-content';
        contentElement.textContent = step.content;
        stepElement.appendChild(contentElement);
        
        // Key Schedule visualization
        if (step.title === "Key Schedule") {
          const keySchedule = document.createElement('div');
          keySchedule.className = 'key-schedule';
          
          const keyScheduleTitle = document.createElement('div');
          keyScheduleTitle.className = 'key-schedule-title';
          keyScheduleTitle.textContent = 'Generated Subkeys (used in reverse order for decryption):';
          keySchedule.appendChild(keyScheduleTitle);
          
          step.subkeys.forEach(subkey => {
            const subkeyElement = document.createElement('div');
            subkeyElement.className = 'subkey';
            
            const subkeyLabel = document.createElement('span');
            subkeyLabel.className = 'subkey-label';
            subkeyLabel.textContent = `Subkey ${subkey.index}:`;
            subkeyElement.appendChild(subkeyLabel);
            
            const subkeyValue = document.createElement('span');
            subkeyValue.textContent = subkey.key;
            subkeyElement.appendChild(subkeyValue);
            
            keySchedule.appendChild(subkeyElement);
          });
          
          stepElement.appendChild(keySchedule);
        }
        
        // Initial or Final Permutation visualization
        if (step.title === "Initial Permutation (IP)" || step.title === "Final Permutation (FP)") {
          const beforeAfter = document.createElement('div');
          beforeAfter.className = 'des-blocks';
          
          // Before block
          const beforeBlock = document.createElement('div');
          beforeBlock.className = 'block';
          
          const beforeTitle = document.createElement('div');
          beforeTitle.className = 'block-title';
          beforeTitle.textContent = 'Before:';
          beforeBlock.appendChild(beforeTitle);
          
          const beforeValue = document.createElement('div');
          beforeValue.textContent = step.before;
          beforeBlock.appendChild(beforeValue);
          
          beforeAfter.appendChild(beforeBlock);
          
          // Arrow
          const arrow = document.createElement('div');
          arrow.className = 'arrow';
          arrow.textContent = '→';
          beforeAfter.appendChild(arrow);
          
          // After block
          const afterBlock = document.createElement('div');
          afterBlock.className = 'block';
          
          const afterTitle = document.createElement('div');
          afterTitle.className = 'block-title';
          afterTitle.textContent = 'After:';
          afterBlock.appendChild(afterTitle);
          
          const afterValue = document.createElement('div');
          afterValue.textContent = step.after;
          afterBlock.appendChild(afterValue);
          
          beforeAfter.appendChild(afterBlock);
          
          stepElement.appendChild(beforeAfter);
        }
        
        // Round visualization
        if (step.title.startsWith("Round")) {
          const roundElement = document.createElement('div');
          roundElement.className = 'des-round';
          
          const roundTitle = document.createElement('div');
          roundTitle.className = 'des-round-title';
          roundTitle.textContent = `Round ${step.title.split(' ')[1]} Details:`;
          roundElement.appendChild(roundTitle);
          
          // Before state
          const beforeState = document.createElement('div');
          beforeState.className = 'des-blocks';
          
          const leftBeforeBlock = document.createElement('div');
          leftBeforeBlock.className = 'block';
          
          const leftBeforeTitle = document.createElement('div');
          leftBeforeTitle.className = 'block-title';
          leftBeforeTitle.textContent = 'Left Half (Before):';
          leftBeforeBlock.appendChild(leftBeforeTitle);
          
          const leftBeforeValue = document.createElement('div');
          leftBeforeValue.textContent = step.leftBefore;
          leftBeforeBlock.appendChild(leftBeforeValue);
          
          beforeState.appendChild(leftBeforeBlock);
          
          const rightBeforeBlock = document.createElement('div');
          rightBeforeBlock.className = 'block';
          
          const rightBeforeTitle = document.createElement('div');
          rightBeforeTitle.className = 'block-title';
          rightBeforeTitle.textContent = 'Right Half (Before):';
          rightBeforeBlock.appendChild(rightBeforeTitle);
          
          const rightBeforeValue = document.createElement('div');
          rightBeforeValue.textContent = step.rightBefore;
          rightBeforeBlock.appendChild(rightBeforeValue);
          
          beforeState.appendChild(rightBeforeBlock);
          
          roundElement.appendChild(beforeState);
          
          // Operation details
          const operationDetails = document.createElement('div');
          operationDetails.className = 'operation';
          operationDetails.textContent = 'Applying F function with Subkey: ' + step.subkey;
          roundElement.appendChild(operationDetails);
          
          // After state
          const afterState = document.createElement('div');
          afterState.className = 'des-blocks';
          
          const leftAfterBlock = document.createElement('div');
          leftAfterBlock.className = 'block';
          
          const leftAfterTitle = document.createElement('div');
          leftAfterTitle.className = 'block-title';
          leftAfterTitle.textContent = 'Left Half (After):';
          leftAfterBlock.appendChild(leftAfterTitle);
          
          const leftAfterValue = document.createElement('div');
          leftAfterValue.textContent = step.leftAfter;
          leftAfterBlock.appendChild(leftAfterValue);
          
          afterState.appendChild(leftAfterBlock);
          
          const rightAfterBlock = document.createElement('div');
          rightAfterBlock.className = 'block';
          
          const rightAfterTitle = document.createElement('div');
          rightAfterTitle.className = 'block-title';
          rightAfterTitle.textContent = 'Right Half (After):';
          rightAfterBlock.appendChild(rightAfterTitle);
          
          const rightAfterValue = document.createElement('div');
          rightAfterValue.textContent = step.rightAfter;
          rightAfterBlock.appendChild(rightAfterValue);
          
          afterState.appendChild(rightAfterBlock);
          
          roundElement.appendChild(afterState);
          
          stepElement.appendChild(roundElement);
        }
        
        stepsContainer.appendChild(stepElement);
      });
    }
  </script>
</body>
</html>